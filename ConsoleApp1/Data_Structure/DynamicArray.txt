
# 배열 Array
고정된 크기 + 연속된 배열요소들의 집합 == 배열을 초기화할 때 총 배열의 요소의 수를 미리 지정해야 한다.

	#경우에 따라, 배열의 요소가 몇 개가 필요한지 미리 알 수가 없으며
	#중간에 필요에 따라, 배열을 확장해야 하는 경우가 있다.

→ .NET 에서 제공하는 클래스 ArrayList와 List<T>

	# 이 동적 배열 클래스들은 배열 확장이 필요한 경우,
	내부적으로 배열 크기가 2배인 새로운 배열을 생성 + 
	모든 기존 배열요소들을 새로운 배열에 복사 + 
	기존 배열 해제 +

#1	참조를 2배짜리로 바꿔준다.
	기존의 배열은 힙 참조를 가지는 맴버변수가 존재하고,
	그 주소를 새 참조에 넣어준다.
	# 가비지 컬렉션 : 기존의 배열을 버린다.
	
#2	-어떻게?-
	A a = new A; //전에 참조하던 것
	a = new A; 

	int[] arr = new int[4];
	int[] temp = new int[arr.Length *2];
	Array.Copy(arr,temp, arr.Length);
	arr= temp;
	//가비지 컬렉터가 알아서 수거 해 간다.

	
	n개일 때, n개에 대해 시간이 얼마나 걸리나:  선형적으로 
	# 시간 복잡도 = 배열과 같이 index로 접근한다면, O(1) 값으로 검색한다면 O(n)을 갖는다.

	공간이 얼마나 걸리나
	# 공간 복잡도


	빅 오메가 : 가장 최선의 경우 : 큰 의미 없다. 
	빅 세터 : 평균적인 경우
	(자료갯수 상관없이 그대로 넣어주면 된다 빅 세터, 빅 오메가 1) : 

	빅 오 : 최악의 경우 : 기준으로 따진다. O(n)


#3	값을 접근하고 싶을때, 인덱스는 특정 값을 바로 찾음
	find함수는 값을 따라 동일한 값을 For루프로 찾는것
	즉, 요소 갯수가 많이질수록 성능이 저하된다.
	

#4	삭제할 때, n개 자료갯수: 시간 복잡도는 어떨것 같은지 추론해보기
	remove함수가 내부적으로 어떻게 돌아가는지
	중간에 지우고 쭉 밀어버린다. ( 빈칸 지우기 )
	최악의 경우 : 빅오노테이션 F(x) = ax + b; O(n) 선형
	노드는 다음것 연결을 바꿔준다.
	

#5	ArrayList 데이터가 논제네릭,
	보통은 같은 타입을 사용하기 떄문에, 
	또 Object로 Box/UnBoxing 일어난다. 특별한 경우 데이터 경우 아니라면 사용 x

	generic 타입은 List<T> 으로 사용한다.


배열의 요소가 Object 타입 Non_Generic 동적 배열 클래스
.NET의 Non_Generic 클래스들은 System.Collections 네임스페이스에 존재

	# 단점이 박싱/언박싱 일어난다.
	ArrayList는 배열 요소를 읽어 사용할 때, Object

#6	Linked List<T> 아이템 삽입 방법  
	Add~ After : 선택 부분 뒤
	Add~ Before : 선택 부분 앞
	Add~ first : 맨 앞 
	Add~ Last :  맨 뒤

	- 특정 노드를 알 수 있으므로, 삽입 알고리즘은 O(1)
	- 노드를 알 수 없는 것은, 탐색 알고리즘이다.

#7 삭제 알고리즘도 O(1), 앞뒤 노드 연결 수정만하면 됨

#8 Linked LIst vs 동적배열 성능
	- 탐색 복잡도 : 
		동적 배열은 배열 베이스 인덱서 O1 일반주소를 알 때 유리 (연속적)
		삽입 삭제가 빈번한 경우 노드식 접근이 유리하므로, 링크드 리스트 
		( 하나하나가 랜덤하게 개체로 존재한다 : 전부 찾을 가능성이 낮아서 캐시미스가 잦다.)
		
