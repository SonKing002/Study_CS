HashTable 

충돌일어나지 않은 헤쉬가 없다.
적당한 충돌과 적당한 크기가 이상적인 헤쉬이다.

#	복잡해지면, 충돌 가능성 낮다.
	단순하면 헤쉬 값이 한 쪽이 쏠리므로 그 쪽의 연산이 높아진다.

	헤쉬함수 그대로 두고, 충돌을 일으키지 않으려면
	용량을 늘려야한다.

	모듈러 연산 - 나머지 연산을 한다.

	키의 값을 조합한다. = 그 값이 인덱스로 사용되면 헤시테이블 (배열)의 사이즈가 넘어가버린다.

	전체 크기를 가지고 모듈러 나머지 연산을 하면 천만이 넘어도 값의 범위를 제한해줄 수 있다.

	값의 범위를 늘리면 충돌이 덜 일어난다.

	방법 2가지 >
1. 헤쉬 함수 복잡도 (검색 추가할때마다 연산량이 많아진다)
2. 헤쉬 크기 자체를 키운다. (노는 메모리가 많아진다)


Key 값 -> 헤쉬함수 -> 메모리 입력할 때, Key 와 Value 

#	아이템 검색하면 시간 복잡도는 얼마나 걸릴까?

->	Key 값 과 Value 1대1 대응이므로 
	세타 1 오메가 1

	"루크" -> 모듈러 연산 -> 인덱스 배열 접근 -> 바로 O(1) 걸린다.
	
#	"루크", "칼" 같은 인덱스로 충돌된다면, 해결 방법들이 존재한다.

->	규칙에 따라 다음 인덱스 부여, 
	다음 노드로 연결하는 방법,
	처음부터 Key-Value Pair 쌍으로 저장한다.
	왜나하면, 충돌났다는 사실을 알 수 없기 때문이다.
	그 키값이 맞는지 확인, 아니면 그 다음! -> 내가 저장한 모든 데이터를 검색하는 순간이다.

	못 찾는다면 연결되어 있는걸 찾기 때문에 O(n)이 걸린다.

	헤쉬테이블 장점 : 헤쉬를 통해 특정값을 구하므로 평균적으로 1이 걸린다.
	검색 삽입 삭제 모두 다, 그런 자료구조는 헤시테이블밖에 없다.

--	
	동적배열 데이터 접근할때 O(1) , 헤시테이블도 세타 오메가 O(1)
	헤쉬함수를 이용하기 때문에 동적배열은 인덱스를 통해 바로 접근하므로 
	동적배열 성능이 더 좋다.